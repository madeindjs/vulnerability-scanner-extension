/**
 * @typedef {{init: RequestInit, url: string}} HackPayload
 * @typedef {(payload: HackPayload) => HackPayload[]} TransformRequestInit
 * @typedef {{id: string, description: string, getPayloads: TransformRequestInit}} Hack
 */
const SPECIAL_NUMBER_CHARS = [`,./;'[]\-=`, `<>?:"{}|_+`, "!@#$%^&*()`"];

/**
 * @type {Hack[]}
 */
const hacks = [
  {
    id: "special-number-characters-into-query-request",
    description: "This will inject",
    getPayloads: ({init, url}) => {
      const queryKeys = Array.from(new URL(url).searchParams.keys());

      const isApplicable = queryKeys.length > 0;

      if (!isApplicable) {
        return [];
      }

      /** @type {HackPayload[]} */
      const payloads = [];

      for (const queryKey of queryKeys) {
        for (const specialCharacter of SPECIAL_NUMBER_CHARS) {
          const newUrl = new URL(url);
          newUrl.searchParams.set(queryKey, specialCharacter);

          payloads.push({init, url: newUrl.toString()});
        }
      }

      return payloads;
    },
    // TODO: find a way to check if its works
  },
  {
    id: "special-number-characters-into-body-request",
    description: "This will inject",
    getPayloads: ({init, url}) => {
      const isApplicable =
        typeof init.body === "object" &&
        init.body !== null &&
        Object.keys(init).length > 0;

      if (!isApplicable) {
        return [];
      }

      /** @type {object} */
      const body = init.body;

      /** @type {HackPayload[]} */
      const payloads = [];

      for (const bodyKey of Object.keys(init.body)) {
        for (const specialCharacter of SPECIAL_NUMBER_CHARS) {
          const newBody = {
            ...body,
            [bodyKey]: specialCharacter,
          };
          payloads.push({init: {...init, body: JSON.stringify(newBody)}, url});
        }
      }

      return payloads;
    },
    // TODO: find a way to check if its works
  },
];

module.exports = {
  hacks,
};
