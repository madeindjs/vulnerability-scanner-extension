// @ts-check

const {isStatusIncludedInCategories} = require("./utils");

/**
 * @typedef {{init: RequestInit, url: string}} HackPayload
 * @typedef {(payload: HackPayload) => HackPayload[]} TransformRequestInit
 * @typedef {{status: 'yes' | 'no' | 'maybe'}} WorkedResponse
 * @typedef {(payload: HackPayload, response: Response) => WorkedResponse} IsWorked
 * @typedef {{id: string, getPayloads: TransformRequestInit, isWorked: IsWorked}} Hack
 */

/**
 */
/**
 * @param {string} param
 * @returns {Hack}
 */
function buildSearchParamInjectionHack(descriptionSuffix, param) {
  return {
    id: `Inject "${param}" in search params request. ${descriptionSuffix}`,
    getPayloads: ({init, url}) => {
      const queryKeys = Array.from(new URL(url).searchParams.keys());

      const isApplicable = queryKeys.length > 0;

      if (!isApplicable) {
        return [];
      }

      /** @type {HackPayload[]} */
      const payloads = [];

      for (const queryKey of queryKeys) {
        const newUrl = new URL(url);
        newUrl.searchParams.set(queryKey, param);

        payloads.push({init, url: newUrl.toString()});
      }

      return payloads;
    },
    isWorked(_payload, response) {
      const goodStatus = isStatusIncludedInCategories(response.status, [
        200,
        300,
        500,
      ]);

      if (goodStatus) {
        return {status: "maybe"};
      } else {
        return {status: "no"};
      }
    },
    // TODO: find a way to check if its works
  };
}

/**
 * @param {string} param
 * @returns {Hack}
 */
function buildBodyInjectionHack(descriptionSuffix, param) {
  return {
    id: `Inject "${param}" in body request. ${descriptionSuffix}`,
    getPayloads: ({init, url}) => {
      const isApplicable =
        typeof init.body === "object" &&
        init.body !== null &&
        Object.keys(init).length > 0;

      if (!isApplicable) {
        return [];
      }

      /** @type {object} */
      const body = init.body;

      /** @type {HackPayload[]} */
      const payloads = [];

      for (const bodyKey of Object.keys(init.body)) {
        const newBody = {
          ...body,
          [bodyKey]: param,
        };
        payloads.push({init: {...init, body: JSON.stringify(newBody)}, url});
      }

      return payloads;
    },
    isWorked(_payload, response) {
      const goodStatus = isStatusIncludedInCategories(response.status, [
        200,
        300,
        500,
      ]);

      if (goodStatus) {
        return {status: "maybe"};
      } else {
        return {status: "no"};
      }
    },
    // TODO: find a way to check if its works
  };
}

/** @type {Hack} */

/**
 * @type {Hack[]}
 */
const hacks = [];

/** @type {{value: string, description: string}[]} */
const naughtyCharacters = [
  {
    description: "can be interpreted as numeric",
    value: "-2147483648/-1",
  },
  {
    description: "contain misplaced quotation marks; can cause encoding errors",
    value: `"''''"'"`,
  },
  {
    description: "SQL injection",
    value: `' OR '1'='1`,
  },
  {
    description: "Server Code Injection",
    value: "$USER",
  },
];

for (const {description, value} of naughtyCharacters) {
  hacks.push(
    buildSearchParamInjectionHack(description, value),
    buildBodyInjectionHack(description, value)
  );
}

module.exports = {
  hacks,
};
