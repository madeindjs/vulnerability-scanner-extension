"use strict";
// @ts-check
const {hacks} = require("./hacks");
const {incrementWorks, incrementMaybe} = require("./storage");
const {wait} = require("./utils");
const utils = require("./utils");

class NotHackable extends Error {
  /**
   *
   * @param {chrome.webRequest.WebRequestFullDetails} request
   * @param {string} message
   */
  constructor(request, message) {
    super(
      `[NotHackable] cannot hack ${request.method} ${request.url} - ${message}`
    );
  }
}

class Hacker {
  /**
   * @type {chrome.webRequest.WebRequestFullDetails}
   */
  _request = undefined;
  /**
   * @type {chrome.webRequest.WebResponseHeadersDetails}
   */
  _response = undefined;

  /**
   * @type {BodyInit}
   */
  _requestBody;

  /**
   * @param {chrome.webRequest.WebRequestFullDetails} request
   * @param {chrome.webRequest.WebResponseHeadersDetails} response
   */
  constructor(request, response) {
    this._request = request;
    this._response = response;

    this._checkRequest();
    this._checkResponse();

    this._requestBody = utils.parseWebRequestBody(this._request.requestBody);
  }

  async *work() {
    const init = this._buildRequestInit();

    for (const hack of hacks) {
      for (const payload of hack.getPayloads({init, url: this._request.url})) {
        const debugLabel = `[${Hacker.name}] try ${this._request.method} ${payload.url} ${payload.init} - `;
        try {
          const response = await fetch(payload.url, payload.init);

          const result = hack.isWorked(payload, response);

          switch (result.status) {
            case "no":
              console.log(`${debugLabel} - ${hack.id} not works ðŸ˜¢`);
              await incrementNotWorks();
              break;
            case "yes":
              console.log(`${debugLabel} - ${hack.id} works ðŸ™Œ %o`, response);
              await incrementWorks();
              break;
            case "maybe":
              console.log(`${debugLabel} - ${hack.id} maybe works ðŸ¤·`);
              await incrementMaybe();
              break;
          }
        } catch (e) {
          // TODO not works if get 40
          console.log(`${debugLabel} - ${hack.id} error %o`, e);
          await incrementNotWorks();
        } finally {
          yield;
        }
        await wait(2_000);
      }
    }
  }

  /**
   * Analyze response
   * @param {Response} response
   */
  _isHackWorked(response) {
    const statusCategory = Math.ceil(response.status / 100) * 100;

    // TODO improve this

    switch (statusCategory) {
      case 200:
      case 300:
      case 500:
        return true;
      case 400:
        return false;
      default:
        false;
    }

    if (response.status) {
      return false;
    }

    return true;
  }

  /**
   * @returns {RequestInit}
   */
  _buildRequestInit() {
    /** @type {HeadersInit} */
    const headers = this._request.requestHeaders
      .filter(({binaryValue}) => binaryValue === undefined)
      .reduce((result, header) => {
        result[header.name] = header.value;
        return result;
      }, {});

    // TODO Not works
    // headers["user-Agent"] = "SecurityScanner/0.0.1";

    return {method: this._request.method, body: this._requestBody, headers};
  }

  _checkRequest() {
    if (this._request.requestBody === undefined) {
      throw new NotHackable(this._request, `request body is undefined`);
    }
  }

  _checkResponse() {
    const responseContentType = utils.getHeaderValue(
      this._response.responseHeaders,
      "content-type"
    );

    const isHackableContentType = [
      "multipart/from-data",
      "application/json",
      "text/html",
    ].some((header) => responseContentType?.startsWith(header));

    if (!isHackableContentType) {
      throw new NotHackable(
        this._request,
        `incompatible "Content-Type: ${responseContentType}"`
      );
    }
  }
}

module.exports = {
  Hacker,
  NotHackable,
};
