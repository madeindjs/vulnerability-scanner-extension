module.exports = {
  /**
   *
   * @param {number} ms
   */
  wait(ms = 1000) {
    return new Promise((res) => setTimeout(res, ms));
  },
  /**
   * @param {chrome.webRequest.HttpHeader[]} headers
   * @param {string} name
   * @returns {string | undefined}
   */
  getHeaderValue(headers, name) {
    return headers.find((header) => header.name.toLowerCase() === name)?.value;
  },

  /**
   * @param {chrome.webRequest.WebRequestBody} requestBody
   * @returns {string | object | undefined}
   */
  parseWebRequestBody(requestBody) {
    if (requestBody.formData !== undefined) {
      return requestBody.formData;
    }

    if (requestBody?.raw === undefined) {
      return undefined;
    }

    const body = decodeURIComponent(
      String.fromCharCode.apply(null, new Uint8Array(requestBody.raw[0].bytes))
    );

    try {
      return JSON.parse(body);
    } catch {
      return body;
    }
  },

  /**
   * @param {chrome.webNavigation.GetFrameDetails} getFrameDetails
   * @returns {Promise<chrome.webNavigation.GetFrameResultDetails>}
   */
  // getFrame(getFrameDetails) {
  //   return new Promise((res, rej) => {
  //     chrome.webNavigation.getFrame(getFrameDetails, (details) => {
  //       if (details && details.url) {
  //         return res(details);
  //       }
  //       return rej(Error("Cannot get frame"));
  //     });
  //   });
  // },

  /**
   * Analyze response
   * @param {number} status
   * @param {number[]} statusCategories
   */
  isStatusIncludedInCategories(status, statusCategories) {
    const statusCategory = Math.ceil(status / 100) * 100;

    return statusCategories.includes(statusCategory);

    // TODO improve this

    switch (statusCategory) {
      case 200:
      case 300:
      case 500:
        return true;
      case 400:
        return false;
      default:
        false;
    }

    if (response.status) {
      return false;
    }

    return true;
  },
};
