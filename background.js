// @ts-check

/**
 * @typedef {{init: RequestInit, url: string}} HackPayload
 * @typedef {(payload: HackPayload) => HackPayload[]} TransformRequestInit
 * @typedef {{id: string, description: string, getPayloads: TransformRequestInit}} Hack
 */

/**
 * @type {Hack[]}
 */
const hacks = [
  {
    id: "special-characters-into-body-request",
    description: "This will inject",
    getPayloads: ({init, url}) => {
      const isApplicable =
        typeof init.body === "object" &&
        init.body !== null &&
        Object.keys(init).length > 0;

      if (!isApplicable) {
        return [];
      }

      /** @type {object} */
      const body = init.body;

      const specialCharacters = [`,./;'[]\-=`, `<>?:"{}|_+`, "!@#$%^&*()`"];

      /** @type {HackPayload[]} */
      const payloads = [];

      for (const bodyKey of Object.keys(init.body)) {
        for (const specialCharacter of specialCharacters) {
          const newBody = {
            ...body,
            [bodyKey]: specialCharacter,
          };
          payloads.push({init: {...init, body: JSON.stringify(newBody)}, url});
        }
      }

      return payloads;
    },
    // TODO: find a way to check if its works
  },
];

/**
 * @type {Map<string, chrome.webRequest.WebRequestFullDetails>}
 */
const requests = new Map();

/**
 * @type {Map<string, chrome.webRequest.WebResponseDetails>}
 */
const responses = new Map();

const tries = [];

const utils = {
  /**
   * @param {chrome.webRequest.HttpHeader[]} headers
   * @param {string} name
   * @returns {string | undefined}
   */
  getHeaderValue(headers, name) {
    return headers.find((header) => header.name.toLowerCase() === name)?.value;
  },

  /**
   * @param {chrome.webRequest.WebRequestBody} requestBody
   * @returns {string | object | undefined}
   */
  parseWebRequestBody(requestBody) {
    if (requestBody.formData !== undefined) {
      return requestBody.formData;
    }

    if (requestBody?.raw === undefined) {
      return undefined;
    }

    const body = decodeURIComponent(
      String.fromCharCode.apply(null, new Uint8Array(requestBody.raw[0].bytes))
    );

    try {
      return JSON.parse(body);
    } catch {
      return body;
    }
  },

  /**
   * @param {chrome.webNavigation.GetFrameDetails} getFrameDetails
   * @returns {Promise<chrome.webNavigation.GetFrameResultDetails>}
   */
  getFrame(getFrameDetails) {
    return new Promise((res, rej) => {
      chrome.webNavigation.getFrame(getFrameDetails, (details) => {
        if (details && details.url) {
          return res(details);
        }
        return rej(Error("Cannot get frame"));
      });
    });
  },

  tryPayload() {},
};

class NotHackable extends Error {
  /**
   *
   * @param {chrome.webRequest.WebRequestFullDetails} request
   * @param {string} message
   */
  constructor(request, message) {
    super(
      `[NotHackable] cannot hack ${request.method} ${request.url} - ${message}`
    );
  }
}

class Hacker {
  _tries = [];
  /**
   * @type {chrome.webRequest.WebRequestFullDetails}
   */
  _request = undefined;
  /**
   * @type {chrome.webRequest.WebResponseHeadersDetails}
   */
  _response = undefined;

  /**
   * @type {BodyInit}
   */
  _requestBody;

  /**
   * @param {chrome.webRequest.WebRequestFullDetails} request
   * @param {chrome.webRequest.WebResponseHeadersDetails} response
   */
  constructor(request, response) {
    this._request = request;
    this._response = response;

    this._checkRequest();
    this._checkResponse();

    this._requestBody = utils.parseWebRequestBody(this._request.requestBody);
  }

  async work() {
    const debugLabel = `[${Hacker.name}] work for ${this._request.method} ${this._request.url} - `;

    const init = this._buildRequestInit();

    console.log(debugLabel);

    for (const hack of hacks) {
      for (const payload of hack.getPayloads({init, url: this._request.url})) {
        try {
          const response = await fetch(payload.url, payload.init);

          if (this._isHackWorked(response)) {
            console.log(`${debugLabel} - ${hack.id} works ðŸ™Œ %o`, response);
          } else {
            console.log(`${debugLabel} - ${hack.id} not works ðŸ˜¢`);
          }
        } catch (e) {
          // TODO not works if get 40
          console.log(`${debugLabel} - ${hack.id} error %o`, e);
        }
      }
    }
  }

  /**
   * Analyze response
   * @param {Response} response
   */
  _isHackWorked(response) {
    const statusCategory = Math.ceil(response.status / 100) * 100;

    // TODO improve this

    switch (statusCategory) {
      case 200:
      case 300:
      case 500:
        return true;
      case 400:
        return false;
      default:
        false;
    }

    if (response.status) {
      return false;
    }

    return true;
  }

  /**
   * @returns {RequestInit}
   */
  _buildRequestInit() {
    /** @type {HeadersInit} */
    const headers = this._request.requestHeaders
      .filter(({binaryValue}) => binaryValue === undefined)
      .reduce((result, header) => {
        result[header.name] = header.value;
        return result;
      }, {});

    // TODO Not works
    // headers["user-Agent"] = "SecurityScanner/0.0.1";

    return {method: this._request.method, body: this._requestBody, headers};
  }

  _checkRequest() {
    if (this._request.requestBody === undefined) {
      throw new NotHackable(this._request, `request body is undefined`);
    }
  }

  _checkResponse() {
    const responseContentType = utils.getHeaderValue(
      this._response.responseHeaders,
      "content-type"
    );

    const isHackableContentType = [
      "multipart/from-data",
      "application/json",
      "text/html",
    ].some((header) => responseContentType?.startsWith(header));

    if (!isHackableContentType) {
      throw new NotHackable(
        this._request,
        `incompatible "Content-Type: ${responseContentType}"`
      );
    }
  }
}

/**
 *
 * @param {chrome.webRequest.WebResponseHeadersDetails} response
 * @param {chrome.webNavigation.GetFrameResultDetails} frameDetails
 */
async function processResponse(response, frameDetails) {
  const request = requests.get(response.requestId);

  if (frameDetails.errorOccurred === true) {
    return;
  }

  if (request === undefined) {
    return console.warn(`[processResponse] cannot find associated request`);
  }

  try {
    const worker = new Hacker(request, response);
    await worker.work();
  } catch (error) {
    if (error instanceof NotHackable) {
      console.warn(error.message);
    } else {
      throw error;
    }
  }
}
// Listeners

// start

function registerListeners() {
  /**
   * @param {chrome.webRequest.WebRequestBodyDetails} details
   */
  function onBeforeRequestListener(details) {
    requests.set(details.requestId, details);
    // console.log(`onBeforeRequest %o`, details);
  }

  /**
   *
   * @param {chrome.webRequest.WebRequestHeadersDetails} details
   */
  function onSendHeadersListener(details) {
    const request = requests.get(details.requestId);

    if (request === undefined) {
      return console.warn(
        `[onSendHeadersListener] cannot find associated request`
      );
    }

    request.requestHeaders = details.requestHeaders;
  }

  /**
   * @param {chrome.webRequest.WebResponseHeadersDetails} details
   */
  function onHeadersReceivedListener(details) {
    // console.log(`onHeadersReceivedListener %o`, details);
  }

  /**
   *
   * @param {chrome.webRequest.WebRedirectionResponseDetails} details
   */
  function onBeforeRedirectListener(details) {
    // console.log(`onBeforeRedirectListener %o`, details);
  }

  /**
   * @param {chrome.webRequest.WebResponseHeadersDetails} details
   */
  function onResponseStartedListener(details) {
    if (details.frameId < 0) {
      details.frameId = 99999;
    }

    utils
      .getFrame({
        tabId: details.tabId,
        processId: null,
        frameId: details.frameId,
      })
      .then((frameDetails) => processResponse(details, frameDetails))
      .catch(() => {});
  }

  function onCommittedListener(details) {
    // console.log(`onCommittedListener %o`, details);
  }

  function onCompletedListener(details) {
    // console.log(`onCompletedListener %o`, details);
  }

  function onRemovedListener(details) {
    // console.log(`onRemovedListener %o`, details);
  }

  /**
   *
   * @param {any} message
   * @param {chrome.runtime.MessageSender} sender
   * @param {Function} sendResponse
   */
  function onMessageListener(message, sender, sendResponse) {
    // console.log(`onMessageListener %o`, details);
  }

  /** @type {chrome.webRequest.RequestFilter} */
  // const requestFilter = {urls: ["https://*.deepl.com/*"]};
  const requestFilter = {urls: ["https://translate.google.fr/*"]};
  // const urlsFilter = ["http://*/*", "https://*/*"]

  chrome.webRequest.onBeforeRequest.addListener(
    onBeforeRequestListener,
    requestFilter,
    ["requestBody"]
  );

  chrome.webRequest.onSendHeaders.addListener(
    onSendHeadersListener,
    requestFilter,
    ["requestHeaders"]
  );

  chrome.webRequest.onHeadersReceived.addListener(
    onHeadersReceivedListener,
    requestFilter,
    ["responseHeaders"]
  );

  chrome.webRequest.onBeforeRedirect.addListener(
    onBeforeRedirectListener,
    requestFilter,
    []
  );

  chrome.webRequest.onResponseStarted.addListener(
    onResponseStartedListener,
    requestFilter,
    ["responseHeaders"]
  );

  chrome.webNavigation.onCommitted.addListener(onCommittedListener);
  chrome.webNavigation.onCompleted.addListener(onCompletedListener);
  // chrome.tabs.onRemoved.addListener(onRemovedListener);
  chrome.runtime.onMessage.addListener(onMessageListener);
}

registerListeners();
