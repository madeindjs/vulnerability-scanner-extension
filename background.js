// @ts-check

/**
 * @type {Map<string, chrome.webRequest.WebRequestFullDetails>}
 */
const requests = new Map();

/**
 * @type {Map<string, chrome.webRequest.WebResponseDetails>}
 */
const responses = new Map();

const tries = [];

class Hacker {
  _tries = [];
  /**
   * @type {chrome.webRequest.WebRequestFullDetails}
   */
  _request = undefined;

  /**
   *
   * @param {chrome.webRequest.WebRequestFullDetails} request
   * @param {chrome.webRequest.WebResponseHeadersDetails} response
   * @returns {boolean}
   */
  static canBeHacked(request, response) {
    const responseContentType = response.responseHeaders.find(
      ({name}) => name.toLowerCase() === "content-type"
    )?.value;

    // todo check if contains params in query or body

    return ["multipart/from-data", "application/json"].includes(
      responseContentType
    );
  }

  /**
   * @param {chrome.webRequest.WebRequestFullDetails} request
   */
  constructor(request) {
    this._request = request;
  }

  work() {
    this._fetch();
  }

  /**
   * @returns {Promise<Response>}
   */
  _fetch() {
    /**
     * @type {HeadersInit}
     */
    const headers = this._request.requestHeaders
      .filter(({binaryValue}) => binaryValue === undefined)
      .reduce((result, header) => {
        result[header.name] = header.value;
        return result;
      }, {});

    headers["User-Agent"] = "SecurityScanner/0.0.1";
    headers["user-Agent"] = "SecurityScanner/0.0.1";

    let body = this._request?.requestBody?.raw?.toString();

    /**
     * @type {RequestInit}
     */
    const init = {method: this._request.method, body, headers};

    this._tries.push({url: this._request.url, init});

    return fetch(this._request.url, init).then((res) => {
      console.log(`[Hacker._fetch] %o`, res);
      return res;
    });
  }
}

/**
 *
 * @param {chrome.webNavigation.GetFrameDetails} getFrameDetails
 * @returns {Promise<chrome.webNavigation.GetFrameResultDetails>}
 */
function getFrame(getFrameDetails) {
  return new Promise((res, rej) => {
    chrome.webNavigation.getFrame(getFrameDetails, (details) => {
      if (details && details.url) {
        return res(details);
      }
      return rej(Error("Cannot get frame"));
    });
  });
}

/**
 *
 * @param {chrome.webRequest.WebResponseHeadersDetails} response
 * @param {chrome.webNavigation.GetFrameResultDetails} frameDetails
 */
function processResponse(response, frameDetails) {
  const request = requests.get(response.requestId);

  if (frameDetails.errorOccurred === true) {
    return;
  }

  if (request === undefined) {
    return console.warn(`[processResponse] cannot find associated request`);
  }

  if (!Hacker.canBeHacked(request, response)) {
    return;
  }

  const worker = new Hacker(request);
  worker.work();
}
// Listeners

/**
 * @param {chrome.webRequest.WebRequestBodyDetails} details
 */
function onBeforeRequestListener(details) {
  requests.set(details.requestId, details);
  // console.log(`onBeforeRequest %o`, details);
}

/**
 *
 * @param {chrome.webRequest.WebRequestHeadersDetails} details
 */
function onSendHeadersListener(details) {
  const request = requests.get(details.requestId);

  if (request === undefined) {
    return console.warn(
      `[onSendHeadersListener] cannot find associated request`
    );
  }

  request.requestHeaders = details.requestHeaders;
}

/**
 * @param {chrome.webRequest.WebResponseHeadersDetails} details
 */
function onHeadersReceivedListener(details) {
  // console.log(`onHeadersReceivedListener %o`, details);
}

/**
 *
 * @param {chrome.webRequest.WebRedirectionResponseDetails} details
 */
function onBeforeRedirectListener(details) {
  // console.log(`onBeforeRedirectListener %o`, details);
}

/**
 * @param {chrome.webRequest.WebResponseHeadersDetails} details
 */
function onResponseStartedListener(details) {
  if (details.frameId < 0) {
    details.frameId = 99999;
  }

  getFrame({tabId: details.tabId, processId: null, frameId: details.frameId})
    .then((frameDetails) => processResponse(details, frameDetails))
    .catch(() => {});
}

function onCommittedListener(details) {
  // console.log(`onCommittedListener %o`, details);
}

function onCompletedListener(details) {
  // console.log(`onCompletedListener %o`, details);
}

function onRemovedListener(details) {
  // console.log(`onRemovedListener %o`, details);
}

/**
 *
 * @param {any} message
 * @param {chrome.runtime.MessageSender} sender
 * @param {Function} sendResponse
 */
function onMessageListener(message, sender, sendResponse) {
  // console.log(`onMessageListener %o`, details);
}

// start

function registerListeners() {
  chrome.webRequest.onBeforeRequest.addListener(
    onBeforeRequestListener,
    {urls: ["http://*/*", "https://*/*"]},
    ["requestBody"]
  );

  chrome.webRequest.onSendHeaders.addListener(
    onSendHeadersListener,
    {urls: ["http://*/*", "https://*/*"]},
    ["requestHeaders"]
  );

  chrome.webRequest.onHeadersReceived.addListener(
    onHeadersReceivedListener,
    {urls: ["http://*/*", "https://*/*"]},
    ["responseHeaders"]
  );

  chrome.webRequest.onBeforeRedirect.addListener(
    onBeforeRedirectListener,
    {urls: ["http://*/*", "https://*/*"]},
    []
  );

  chrome.webRequest.onResponseStarted.addListener(
    onResponseStartedListener,
    {urls: ["http://*/*", "https://*/*"]},
    ["responseHeaders"]
  );

  chrome.webNavigation.onCommitted.addListener(onCommittedListener);
  chrome.webNavigation.onCompleted.addListener(onCompletedListener);
  // chrome.tabs.onRemoved.addListener(onRemovedListener);
  chrome.runtime.onMessage.addListener(onMessageListener);
}

registerListeners();
